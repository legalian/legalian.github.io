<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Voxel Data Storage | Parker Lawrence portfolio</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Voxel Data Storage" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Data storage is the second challenge to overcome. If the game has a reasonable, fixed size, and you can afford to store all data at once, you might as well just store it in a large 3D array. Geometrically, each element in the 3 dimensional array represents a 1x1x1 area. More often, though, you’ll either want the map size to be infinite or at least large enough that you can’t store all of that information at once. For that, you’ll need to break the map apart into reasonably sized pieces that can be read from and written to memory. There is often a bit of nuance with regards to threading and ensuring that you only attempt to generate mesh for a chunk when its neighbors are loaded too. There is always mesh data along the edge of each chunk that cannot be generated without data from other chunks. This is sometimes referred to as the skirt, which usually has some unique considerations, especially when threading is involved. Each element in each 3 dimensional array is still responsible for a 1x1x1 volume, but additionally, each chunk is responsible for a larger defined volume as well. For very fine voxel resolutions, you’ll want to construct an octree. An octree is a recursive structure where 3D space is recursively subdivided into 8 regions. Any area that is one solid type of voxel does not need to be subdivided and is stored as one id. As you can see in the figure, for finer resolutions, there is a significant reduction in memory usage. The octree offers this reduction because volumetric data often has large, contiguous, homogenous areas. Now that our volumetric data is stored as a tree, we should access it similarly to doing a binary search. The figure below provides a visual explanation of why we can use the binary representation of the block’s coordinates to get its place in the tree. Reading from and writing to a file is still trivial- the octree must be saved recursively. The octree has restrictions on it that allow it to function. The octree always has a ‘bottom’, where it will not divide area any further. Branches must know how far they are above this bottom- this will determine if they are accountable for a 2x2x2 volume, a 4x4x4 volume, an 8x8x8 volume, etc. Branches will always be accountable for cubic volume whose side lengths are a power of two above one. Solid areas that are not subdivided are stored as buds, which are the same but there can be 1x1x1 sized buds. (Other tree structures for storing different kinds of data will always be size 1x1x1). In order to use an octree with an infinite world size, the last two methods can be combined- data is loaded and unloaded in portions with an octree representation. Instead of having an octree for each chunk, though, it’s faster to combine all of the octrees into one octree that expands as more data is loaded in. Without negative values, it’s easy to see how this would work. The tree representing some chunk is loaded, and then must be inserted into the world tree. First, the world tree must grow large enough to encapsulate the area inhabited by the chunk. Growing an octree is done by creating a new root node whose children consist of seven buds and the previous root node. The previous root node will be the lower left child, which ensures that the octree will expand up and to the right. The new root node will be twice as large in each dimension. Then, the tree must recursively divide the appropriate bud until there is a spot for the chunk to be placed. To divide a bud, the bud is replaced with a branch of the same size whose children are smaller buds. Only then can the chunk be placed in the world tree. To allow for negative values, a change must be made to the octree. When the tree expands, it has to expand in the negative direction as well as the positive direction. To accomplish this, the octree will alternate between making the old root node the new root node’s lower left child and making it the new root node’s upper right child. Geometrically speaking, the octree alternates between doubling forward and doubling backward. This is an extremely effective method for encapsulating all of space, but it makes finding locations in the tree more difficult. A voxel’s location in the tree is no longer the same as its binary representation. Relying on the binary representation of the number to ‘wrap around’ would be unacceptable because it would cause discontinuities once the tree expands and begins taking the next most significant bit into consideration. The coordinates of each voxel must be transformed into ‘address space’ before their binary representations may be used to find its position in the tree. This transformation can be observed to be associative with addition (voxels have different addresses but consecutive addresses are still consecutive), which means to transform into address space is to add a certain offset to the coordinate and then take the binary representation. That offset should be 0 in address space, which logically I know has to be the repeating binary pattern 10101010.... Because the tree alternates between expanding positively and negatively, alternating between going down the left side of the tree and the right side will eventually end up at zero. I use a slight modification to this that ensures that chunk coordinates can be found by truncated division by the chunk size. The tree can also be used to store hermitian data, but some small changes should be made. In addition to branches, for areas that contain changes, and buds, for uniform areas, There should also be features for areas that need to store a vertex and leaves for areas that need to store edges. As opposed to branches and buds, features and leaves are always size 1x1x1. The following diagram shows the inheritance tree or these structures." />
<meta property="og:description" content="Data storage is the second challenge to overcome. If the game has a reasonable, fixed size, and you can afford to store all data at once, you might as well just store it in a large 3D array. Geometrically, each element in the 3 dimensional array represents a 1x1x1 area. More often, though, you’ll either want the map size to be infinite or at least large enough that you can’t store all of that information at once. For that, you’ll need to break the map apart into reasonably sized pieces that can be read from and written to memory. There is often a bit of nuance with regards to threading and ensuring that you only attempt to generate mesh for a chunk when its neighbors are loaded too. There is always mesh data along the edge of each chunk that cannot be generated without data from other chunks. This is sometimes referred to as the skirt, which usually has some unique considerations, especially when threading is involved. Each element in each 3 dimensional array is still responsible for a 1x1x1 volume, but additionally, each chunk is responsible for a larger defined volume as well. For very fine voxel resolutions, you’ll want to construct an octree. An octree is a recursive structure where 3D space is recursively subdivided into 8 regions. Any area that is one solid type of voxel does not need to be subdivided and is stored as one id. As you can see in the figure, for finer resolutions, there is a significant reduction in memory usage. The octree offers this reduction because volumetric data often has large, contiguous, homogenous areas. Now that our volumetric data is stored as a tree, we should access it similarly to doing a binary search. The figure below provides a visual explanation of why we can use the binary representation of the block’s coordinates to get its place in the tree. Reading from and writing to a file is still trivial- the octree must be saved recursively. The octree has restrictions on it that allow it to function. The octree always has a ‘bottom’, where it will not divide area any further. Branches must know how far they are above this bottom- this will determine if they are accountable for a 2x2x2 volume, a 4x4x4 volume, an 8x8x8 volume, etc. Branches will always be accountable for cubic volume whose side lengths are a power of two above one. Solid areas that are not subdivided are stored as buds, which are the same but there can be 1x1x1 sized buds. (Other tree structures for storing different kinds of data will always be size 1x1x1). In order to use an octree with an infinite world size, the last two methods can be combined- data is loaded and unloaded in portions with an octree representation. Instead of having an octree for each chunk, though, it’s faster to combine all of the octrees into one octree that expands as more data is loaded in. Without negative values, it’s easy to see how this would work. The tree representing some chunk is loaded, and then must be inserted into the world tree. First, the world tree must grow large enough to encapsulate the area inhabited by the chunk. Growing an octree is done by creating a new root node whose children consist of seven buds and the previous root node. The previous root node will be the lower left child, which ensures that the octree will expand up and to the right. The new root node will be twice as large in each dimension. Then, the tree must recursively divide the appropriate bud until there is a spot for the chunk to be placed. To divide a bud, the bud is replaced with a branch of the same size whose children are smaller buds. Only then can the chunk be placed in the world tree. To allow for negative values, a change must be made to the octree. When the tree expands, it has to expand in the negative direction as well as the positive direction. To accomplish this, the octree will alternate between making the old root node the new root node’s lower left child and making it the new root node’s upper right child. Geometrically speaking, the octree alternates between doubling forward and doubling backward. This is an extremely effective method for encapsulating all of space, but it makes finding locations in the tree more difficult. A voxel’s location in the tree is no longer the same as its binary representation. Relying on the binary representation of the number to ‘wrap around’ would be unacceptable because it would cause discontinuities once the tree expands and begins taking the next most significant bit into consideration. The coordinates of each voxel must be transformed into ‘address space’ before their binary representations may be used to find its position in the tree. This transformation can be observed to be associative with addition (voxels have different addresses but consecutive addresses are still consecutive), which means to transform into address space is to add a certain offset to the coordinate and then take the binary representation. That offset should be 0 in address space, which logically I know has to be the repeating binary pattern 10101010.... Because the tree alternates between expanding positively and negatively, alternating between going down the left side of the tree and the right side will eventually end up at zero. I use a slight modification to this that ensures that chunk coordinates can be found by truncated division by the chunk size. The tree can also be used to store hermitian data, but some small changes should be made. In addition to branches, for areas that contain changes, and buds, for uniform areas, There should also be features for areas that need to store a vertex and leaves for areas that need to store edges. As opposed to branches and buds, features and leaves are always size 1x1x1. The following diagram shows the inheritance tree or these structures." />
<link rel="canonical" href="http://localhost:4000/voxel/2018/08/13/voxel-data-storage.html" />
<meta property="og:url" content="http://localhost:4000/voxel/2018/08/13/voxel-data-storage.html" />
<meta property="og:site_name" content="Parker Lawrence portfolio" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-08-13T10:39:54-04:00" />
<script type="application/ld+json">
{"description":"Data storage is the second challenge to overcome. If the game has a reasonable, fixed size, and you can afford to store all data at once, you might as well just store it in a large 3D array. Geometrically, each element in the 3 dimensional array represents a 1x1x1 area. More often, though, you’ll either want the map size to be infinite or at least large enough that you can’t store all of that information at once. For that, you’ll need to break the map apart into reasonably sized pieces that can be read from and written to memory. There is often a bit of nuance with regards to threading and ensuring that you only attempt to generate mesh for a chunk when its neighbors are loaded too. There is always mesh data along the edge of each chunk that cannot be generated without data from other chunks. This is sometimes referred to as the skirt, which usually has some unique considerations, especially when threading is involved. Each element in each 3 dimensional array is still responsible for a 1x1x1 volume, but additionally, each chunk is responsible for a larger defined volume as well. For very fine voxel resolutions, you’ll want to construct an octree. An octree is a recursive structure where 3D space is recursively subdivided into 8 regions. Any area that is one solid type of voxel does not need to be subdivided and is stored as one id. As you can see in the figure, for finer resolutions, there is a significant reduction in memory usage. The octree offers this reduction because volumetric data often has large, contiguous, homogenous areas. Now that our volumetric data is stored as a tree, we should access it similarly to doing a binary search. The figure below provides a visual explanation of why we can use the binary representation of the block’s coordinates to get its place in the tree. Reading from and writing to a file is still trivial- the octree must be saved recursively. The octree has restrictions on it that allow it to function. The octree always has a ‘bottom’, where it will not divide area any further. Branches must know how far they are above this bottom- this will determine if they are accountable for a 2x2x2 volume, a 4x4x4 volume, an 8x8x8 volume, etc. Branches will always be accountable for cubic volume whose side lengths are a power of two above one. Solid areas that are not subdivided are stored as buds, which are the same but there can be 1x1x1 sized buds. (Other tree structures for storing different kinds of data will always be size 1x1x1). In order to use an octree with an infinite world size, the last two methods can be combined- data is loaded and unloaded in portions with an octree representation. Instead of having an octree for each chunk, though, it’s faster to combine all of the octrees into one octree that expands as more data is loaded in. Without negative values, it’s easy to see how this would work. The tree representing some chunk is loaded, and then must be inserted into the world tree. First, the world tree must grow large enough to encapsulate the area inhabited by the chunk. Growing an octree is done by creating a new root node whose children consist of seven buds and the previous root node. The previous root node will be the lower left child, which ensures that the octree will expand up and to the right. The new root node will be twice as large in each dimension. Then, the tree must recursively divide the appropriate bud until there is a spot for the chunk to be placed. To divide a bud, the bud is replaced with a branch of the same size whose children are smaller buds. Only then can the chunk be placed in the world tree. To allow for negative values, a change must be made to the octree. When the tree expands, it has to expand in the negative direction as well as the positive direction. To accomplish this, the octree will alternate between making the old root node the new root node’s lower left child and making it the new root node’s upper right child. Geometrically speaking, the octree alternates between doubling forward and doubling backward. This is an extremely effective method for encapsulating all of space, but it makes finding locations in the tree more difficult. A voxel’s location in the tree is no longer the same as its binary representation. Relying on the binary representation of the number to ‘wrap around’ would be unacceptable because it would cause discontinuities once the tree expands and begins taking the next most significant bit into consideration. The coordinates of each voxel must be transformed into ‘address space’ before their binary representations may be used to find its position in the tree. This transformation can be observed to be associative with addition (voxels have different addresses but consecutive addresses are still consecutive), which means to transform into address space is to add a certain offset to the coordinate and then take the binary representation. That offset should be 0 in address space, which logically I know has to be the repeating binary pattern 10101010.... Because the tree alternates between expanding positively and negatively, alternating between going down the left side of the tree and the right side will eventually end up at zero. I use a slight modification to this that ensures that chunk coordinates can be found by truncated division by the chunk size. The tree can also be used to store hermitian data, but some small changes should be made. In addition to branches, for areas that contain changes, and buds, for uniform areas, There should also be features for areas that need to store a vertex and leaves for areas that need to store edges. As opposed to branches and buds, features and leaves are always size 1x1x1. The following diagram shows the inheritance tree or these structures.","@type":"BlogPosting","url":"http://localhost:4000/voxel/2018/08/13/voxel-data-storage.html","headline":"Voxel Data Storage","dateModified":"2018-08-13T10:39:54-04:00","datePublished":"2018-08-13T10:39:54-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/voxel/2018/08/13/voxel-data-storage.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Parker Lawrence portfolio" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Parker Lawrence portfolio</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/breadboardcomputer.html">Breadboard Computer</a><a class="page-link" href="/puzzlegenerator.html">Puzzle Generator</a><a class="page-link" href="/tedtalk.html">TED Talk</a><a class="page-link" href="/voxelengine.html">Voxel Engine</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Voxel Data Storage</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-08-13T10:39:54-04:00" itemprop="datePublished">Aug 13, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>
Data storage is the second challenge to overcome. If the game has a reasonable, fixed size, and you can afford to store all data at once, you might as well just store it in a large 3D array. Geometrically, each element in the 3 dimensional array represents a 1x1x1 area.
</p>
<p><img src="http://localhost:4000/assets/vox/chapter2/figure1.png" alt="figure 1" /></p>
<p>
More often, though, you’ll either want the map size to be infinite or at least large enough that you can’t store all of that information at once. For that, you’ll need to break the map apart into reasonably sized pieces that can be read from and written to memory. There is often a bit of nuance with regards to threading and ensuring that you only attempt to generate mesh for a chunk when its neighbors are loaded too. There is always mesh data along the edge of each chunk that cannot be generated without data from other chunks. This is sometimes referred to as the skirt, which usually has some unique considerations, especially when threading is involved. Each element in each 3 dimensional array is still responsible for a 1x1x1 volume, but additionally, each chunk is responsible for a larger defined volume as well.
</p>
<p><img src="http://localhost:4000/assets/vox/chapter2/figure2.png" alt="figure 2" /></p>
<p>
For very fine voxel resolutions, you’ll want to construct an octree. An octree is a recursive structure where 3D space is recursively subdivided into 8 regions. Any area that is one solid type of voxel does not need to be subdivided and is stored as one id. As you can see in the figure, for finer resolutions, there is a significant reduction in memory usage. The octree offers this reduction because volumetric data often has large, contiguous, homogenous areas. Now that our volumetric data is stored as a tree, we should access it similarly to doing a binary search. The figure below provides a visual explanation of why we can use the binary representation of the block’s coordinates to get its place in the tree. Reading from and writing to a file is still trivial- the octree must be saved recursively.
The octree has restrictions on it that allow it to function. The octree always has a ‘bottom’, where it will not divide area any further. Branches must know how far they are above this bottom- this will determine if they are accountable for a 2x2x2 volume, a 4x4x4 volume, an 8x8x8 volume, etc. Branches will always be accountable for cubic volume whose side lengths are a power of two above one. Solid areas that are not subdivided are stored as buds, which are the same but there can be 1x1x1 sized buds. (Other tree structures for storing different kinds of data will always be size 1x1x1).
</p>
<p><img src="http://localhost:4000/assets/vox/chapter2/figure3.png" alt="figure 3" /></p>
<p>
In order to use an octree with an infinite world size, the last two methods can be combined- data is loaded and unloaded in portions with an octree representation. Instead of having an octree for each chunk, though, it’s faster to combine all of the octrees into one octree that expands as more data is loaded in. Without negative values, it’s easy to see how this would work. The tree representing some chunk is loaded, and then must be inserted into the world tree. First, the world tree must grow large enough to encapsulate the area inhabited by the chunk. Growing an octree is done by creating a new root node whose children consist of seven buds and the previous root node. The previous root node will be the lower left child, which ensures that the octree will expand up and to the right. The new root node will be twice as large in each dimension. Then, the tree must recursively divide the appropriate bud until there is a spot for the chunk to be placed. To divide a bud, the bud is replaced with a branch of the same size whose children are smaller buds. Only then can the chunk be placed in the world tree.
</p>
<p><img src="http://localhost:4000/assets/vox/chapter2/figure4.png" alt="figure 4" /></p>
<p>
To allow for negative values, a change must be made to the octree. When the tree expands, it has to expand in the negative direction as well as the positive direction. To accomplish this, the octree will alternate between making the old root node the new root node’s lower left child and making it the new root node’s upper right child. Geometrically speaking, the octree alternates between doubling forward and doubling backward. This is an extremely effective method for encapsulating all of space, but it makes finding locations in the tree more difficult. 
</p>
<p><img src="http://localhost:4000/assets/vox/chapter2/figure5.png" alt="figure 5" /></p>
<p>
A voxel’s location in the tree is no longer the same as its binary representation. Relying on the binary representation of the number to ‘wrap around’ would be unacceptable because it would cause discontinuities once the tree expands and begins taking the next most significant bit into consideration. The coordinates of each voxel must be transformed into ‘address space’ before their binary representations may be used to find its position in the tree. This transformation can be observed to be associative with addition (voxels have different addresses but consecutive addresses are still consecutive), which means to transform into address space is to add a certain offset to the coordinate and then take the binary representation. That offset should be 0 in address space, which logically I know has to be the repeating binary pattern 10101010.... Because the tree alternates between expanding positively and negatively, alternating between going down the left side of the tree and the right side will eventually end up at zero. I use a slight modification to this that ensures that chunk coordinates can be found by truncated division by the chunk size. 
</p>
<p><img src="http://localhost:4000/assets/vox/chapter2/figure6.png" alt="figure 6" /></p>
<p>
The tree can also be used to store hermitian data, but some small changes should be made. In addition to branches, for areas that contain changes, and buds, for uniform areas, There should also be features for areas that need to store a vertex and leaves for areas that need to store edges. As opposed to branches and buds, features and leaves are always size 1x1x1. The following diagram shows the inheritance tree or these structures.
</p>
<p><img src="http://localhost:4000/assets/vox/chapter2/figure7.png" alt="figure 7" /></p>


  </div><a class="u-url" href="/voxel/2018/08/13/voxel-data-storage.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Parker Lawrence portfolio</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Parker Lawrence portfolio</li><li><a class="u-email" href="mailto:liverspleenkidney@gmail.com">liverspleenkidney@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/legalian"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">legalian</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Parker Lawrence&#39;s portfolio website and blog about interesting topics. If you&#39;re working on similar projects or you know Parker Lawrence, you may find this site interesting.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.8.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-08-16T11:56:53-04:00</updated><id>http://localhost:4000/</id><title type="html">Parker Lawrence portfolio</title><subtitle>Parker Lawrence's portfolio website and blog about interesting topics. If you're working on similar projects or you know Parker Lawrence, you may find this site interesting.</subtitle><entry><title type="html">Voxel Level of Detail</title><link href="http://localhost:4000/voxel/2018/08/13/voxel-level-of-detail.html" rel="alternate" type="text/html" title="Voxel Level of Detail" /><published>2018-08-13T10:39:54-04:00</published><updated>2018-08-13T10:39:54-04:00</updated><id>http://localhost:4000/voxel/2018/08/13/voxel-level-of-detail</id><content type="html" xml:base="http://localhost:4000/voxel/2018/08/13/voxel-level-of-detail.html">&lt;p&gt;
Games typically put more detail close to the player and less detail further away. This ensures the game runs smoothly, because less triangles need to be rendered if they occupy a small space on the screen. This concept is called level of detail (or LOD). Game developers forfeit their direct control over level of detail when they make their game a voxel game, but they can get around this by designing a system that can turn volumetric data into a visible mesh with a specified level of detail. The figure below shows meshes generated from the same volumetric data but different levels of detail in 2D.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter3/figure1.png&quot; alt=&quot;figure 1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
Generating a less detailed mesh isn’t terribly difficult. Each branch of the octree must store a vertex, just like the leaves do. Then, each branch with a depth X above the leaves become the new leaves, so that when the mesh generation step occurs, each 2x2x2 region behaves as one feature. In the leaves of the tree, Vertices are placed by minimizing Q(x,y,z), the sum of the squared distance to each nearby tangent plane. When grouping regions together, then, the branch must minimize the sum of each child node’s Q function. This allows vertex calculation to be done for all levels of detail recursively.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter3/figure2.png&quot; alt=&quot;figure 2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
The difficult part comes when polygons must be drawn to stitch together different levels of detail. Enclosed are diagrams and examples of cases that must be handled. Extra triangles must be drawn to ensure the mesh is continuous, but that can be very difficult. Even worse, though, is that any time the level of detail on one chunk must be changed, that could result to tiny changes in the edges of up to six other meshes, requiring full recalculation of each. I solve this problem by storing the main part of the chunk separately from the skirting. The main mesh is generated in each level of detail and does not recalculate unless changed, while the skirt is recalculated each time it or one of its six relevant neighbors are changed. The skirt alone takes much less time to recalculate, and this way level of detail recalculation is minimized. The game can also load a lot more terrain before performance takes a hit, due to level of detail.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter3/figure3.png&quot; alt=&quot;figure 3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
There are many other optimizations done to the game to increase performance. One of which is VBO indexing. This can decrease graphics card memory used for any application, but with dual contouring, it offers an additional benefit. Stitching between vertecies must be recalculated only when the gridlike sampling points change, but the index array does not change when hermit data changes. This means, for small changes to terrain, only part of the mesh generation must be recalculated. 
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter3/figure4.png&quot; alt=&quot;figure 4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
Another optimization (and by far the simplest) is called frustrum culling. The game does not need to render meshes that are outside the camera’s view, so if the game can quickly detect this, many costly draw calls can be avoided. The detection method may have false negatives, but false positives are unacceptable, because then meshes would disappear from the players view. The voxel engine does this by first extracting the top, bottom, left, right, near, and far planes from the camera’s projection matrix, and then testing if the bounding spheres of meshes lies inside those six planes. The math behind this isn’t hard- it boils down to just six dot products, some addition, and some comparison per bounding sphere. It can be tricky to debug, though, because if all is working well, the only noticeable difference is performance. 
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter3/figure5.png&quot; alt=&quot;figure 5&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Games typically put more detail close to the player and less detail further away. This ensures the game runs smoothly, because less triangles need to be rendered if they occupy a small space on the screen. This concept is called level of detail (or LOD). Game developers forfeit their direct control over level of detail when they make their game a voxel game, but they can get around this by designing a system that can turn volumetric data into a visible mesh with a specified level of detail. The figure below shows meshes generated from the same volumetric data but different levels of detail in 2D. Generating a less detailed mesh isn’t terribly difficult. Each branch of the octree must store a vertex, just like the leaves do. Then, each branch with a depth X above the leaves become the new leaves, so that when the mesh generation step occurs, each 2x2x2 region behaves as one feature. In the leaves of the tree, Vertices are placed by minimizing Q(x,y,z), the sum of the squared distance to each nearby tangent plane. When grouping regions together, then, the branch must minimize the sum of each child node’s Q function. This allows vertex calculation to be done for all levels of detail recursively. The difficult part comes when polygons must be drawn to stitch together different levels of detail. Enclosed are diagrams and examples of cases that must be handled. Extra triangles must be drawn to ensure the mesh is continuous, but that can be very difficult. Even worse, though, is that any time the level of detail on one chunk must be changed, that could result to tiny changes in the edges of up to six other meshes, requiring full recalculation of each. I solve this problem by storing the main part of the chunk separately from the skirting. The main mesh is generated in each level of detail and does not recalculate unless changed, while the skirt is recalculated each time it or one of its six relevant neighbors are changed. The skirt alone takes much less time to recalculate, and this way level of detail recalculation is minimized. The game can also load a lot more terrain before performance takes a hit, due to level of detail. There are many other optimizations done to the game to increase performance. One of which is VBO indexing. This can decrease graphics card memory used for any application, but with dual contouring, it offers an additional benefit. Stitching between vertecies must be recalculated only when the gridlike sampling points change, but the index array does not change when hermit data changes. This means, for small changes to terrain, only part of the mesh generation must be recalculated. Another optimization (and by far the simplest) is called frustrum culling. The game does not need to render meshes that are outside the camera’s view, so if the game can quickly detect this, many costly draw calls can be avoided. The detection method may have false negatives, but false positives are unacceptable, because then meshes would disappear from the players view. The voxel engine does this by first extracting the top, bottom, left, right, near, and far planes from the camera’s projection matrix, and then testing if the bounding spheres of meshes lies inside those six planes. The math behind this isn’t hard- it boils down to just six dot products, some addition, and some comparison per bounding sphere. It can be tricky to debug, though, because if all is working well, the only noticeable difference is performance.</summary></entry><entry><title type="html">Voxel Data Visualization</title><link href="http://localhost:4000/voxel/2018/08/13/voxel-data-visualization.html" rel="alternate" type="text/html" title="Voxel Data Visualization" /><published>2018-08-13T10:39:54-04:00</published><updated>2018-08-13T10:39:54-04:00</updated><id>http://localhost:4000/voxel/2018/08/13/voxel-data-visualization</id><content type="html" xml:base="http://localhost:4000/voxel/2018/08/13/voxel-data-visualization.html">&lt;p&gt;
The first thing needed for a voxel engine is called an isosurface. An isosurface is a multidimensional function where negative values are intended to be outside the ‘solid’ and positive values are intended to be inside the solid. Interesting ones that resemble roads, mountains, and valleys can come later, but right now simple isosurfaces like spheres and planes are useful for testing. Isosurfaces are only used to generate the initial terrain- once generated, the terrain can be changed to no longer resemble the function. Isosurface functions only need to be fast to execute- they need not have a known derivative, integral, or any other property. Rather, they are sampled. The function is called at every 3d gridpoint in the game world, with the assumption that for each two points, if one is positive and the other negative, the solid has boundary that exists between those so points.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter1/figure1.png&quot; alt=&quot;figure 1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
The second thing needed for a voxel engine is a method to turn volumetric data into a visible mesh. The simplest way to do this is intuitive: create a square on each boundary between transparent and opaque material. The isosurface must be sampled at each 3d gridpoint, and then this data must be remembered. This is the method most are familiar with, thanks to Minecraft. This is a very fast approach that makes texturing easy, but the results are always blocky.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter1/figure2.png&quot; alt=&quot;figure 2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
The second method, which I also experimented with, is called marching cubes. Marching cubes places all vertices along the line segments connecting the sampling points, and stitches polygons between them according to a lookup table with the opaqueness of the surrounding vertices. To use this method, the program must make an estimate at where boundary of an isosurface lies, given two points, one above zero, one below zero. This is done linearly. The figure below illustrates this in 2D with four vertices and 16 entries in the lookup table, but the concept extends to 3D where eight vertices would be considered with 256 entries in the table. Marching cubes is most commonly used in medical imaging. It produces only smooth meshes (or at least beveled meshes) This is an improvement, because the voxel boundary has another degree of freedom- vertices can be placed anywhere on the line segment between the two sampling points, allowing for ground that isn’t perfectly even.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter1/figure3.png&quot; alt=&quot;figure 3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
The extra degree of freedom is nice, but not perfect- The ability to have sharp corners is sacrificed, but the smoother meshes aren’t perfectly smooth, either. The last method is dual contouring: the Cadillac of isosurface extraction algorithms. The distance along the line segment between sample points must be known, same as marching cubes, but this time the vector perpendicular to the isosurface at that point much also be known. This is called hermitian data, and in addition to the linear method used to estimate the position of the boundary, six extra calls to the sampling function are used to estimate the vector perpendicular to the surface at a given point, which is called the normal. Vertices are then placed inside each box at the location that minimizes the sum of squared distances to each surrounding tangent plane. Then, stitching between vertices is done exactly like in method 1, no lookup table needed. Specifying normal information allows for both smooth and sharp meshes (and everything in between). This is how voxel games break out of their blocky, axis aligned shells.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter1/figure4.png&quot; alt=&quot;figure 4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
Minimizing the squared distance to each tangent plane is a difficult process, but having a little knowledge of multi variable calculus makes things a lot easier. The figure below shows the specific math involved. The nine coefficients for each tangent plane are summed up and then turned into a 3x3 matrix which is solved to get the vertex. I’ve seen people take the pseudo inverse of a matrix with those coefficients with svd decomposition but I’ve gotten better results without that.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter1/figure5.png&quot; alt=&quot;figure 5&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">The first thing needed for a voxel engine is called an isosurface. An isosurface is a multidimensional function where negative values are intended to be outside the ‘solid’ and positive values are intended to be inside the solid. Interesting ones that resemble roads, mountains, and valleys can come later, but right now simple isosurfaces like spheres and planes are useful for testing. Isosurfaces are only used to generate the initial terrain- once generated, the terrain can be changed to no longer resemble the function. Isosurface functions only need to be fast to execute- they need not have a known derivative, integral, or any other property. Rather, they are sampled. The function is called at every 3d gridpoint in the game world, with the assumption that for each two points, if one is positive and the other negative, the solid has boundary that exists between those so points. The second thing needed for a voxel engine is a method to turn volumetric data into a visible mesh. The simplest way to do this is intuitive: create a square on each boundary between transparent and opaque material. The isosurface must be sampled at each 3d gridpoint, and then this data must be remembered. This is the method most are familiar with, thanks to Minecraft. This is a very fast approach that makes texturing easy, but the results are always blocky. The second method, which I also experimented with, is called marching cubes. Marching cubes places all vertices along the line segments connecting the sampling points, and stitches polygons between them according to a lookup table with the opaqueness of the surrounding vertices. To use this method, the program must make an estimate at where boundary of an isosurface lies, given two points, one above zero, one below zero. This is done linearly. The figure below illustrates this in 2D with four vertices and 16 entries in the lookup table, but the concept extends to 3D where eight vertices would be considered with 256 entries in the table. Marching cubes is most commonly used in medical imaging. It produces only smooth meshes (or at least beveled meshes) This is an improvement, because the voxel boundary has another degree of freedom- vertices can be placed anywhere on the line segment between the two sampling points, allowing for ground that isn’t perfectly even. The extra degree of freedom is nice, but not perfect- The ability to have sharp corners is sacrificed, but the smoother meshes aren’t perfectly smooth, either. The last method is dual contouring: the Cadillac of isosurface extraction algorithms. The distance along the line segment between sample points must be known, same as marching cubes, but this time the vector perpendicular to the isosurface at that point much also be known. This is called hermitian data, and in addition to the linear method used to estimate the position of the boundary, six extra calls to the sampling function are used to estimate the vector perpendicular to the surface at a given point, which is called the normal. Vertices are then placed inside each box at the location that minimizes the sum of squared distances to each surrounding tangent plane. Then, stitching between vertices is done exactly like in method 1, no lookup table needed. Specifying normal information allows for both smooth and sharp meshes (and everything in between). This is how voxel games break out of their blocky, axis aligned shells. Minimizing the squared distance to each tangent plane is a difficult process, but having a little knowledge of multi variable calculus makes things a lot easier. The figure below shows the specific math involved. The nine coefficients for each tangent plane are summed up and then turned into a 3x3 matrix which is solved to get the vertex. I’ve seen people take the pseudo inverse of a matrix with those coefficients with svd decomposition but I’ve gotten better results without that.</summary></entry><entry><title type="html">Voxel Data Storage</title><link href="http://localhost:4000/voxel/2018/08/13/voxel-data-storage.html" rel="alternate" type="text/html" title="Voxel Data Storage" /><published>2018-08-13T10:39:54-04:00</published><updated>2018-08-13T10:39:54-04:00</updated><id>http://localhost:4000/voxel/2018/08/13/voxel-data-storage</id><content type="html" xml:base="http://localhost:4000/voxel/2018/08/13/voxel-data-storage.html">&lt;p&gt;
Data storage is the second challenge to overcome. If the game has a reasonable, fixed size, and you can afford to store all data at once, you might as well just store it in a large 3D array. Geometrically, each element in the 3 dimensional array represents a 1x1x1 area.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter2/figure1.png&quot; alt=&quot;figure 1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
More often, though, you’ll either want the map size to be infinite or at least large enough that you can’t store all of that information at once. For that, you’ll need to break the map apart into reasonably sized pieces that can be read from and written to memory. There is often a bit of nuance with regards to threading and ensuring that you only attempt to generate mesh for a chunk when its neighbors are loaded too. There is always mesh data along the edge of each chunk that cannot be generated without data from other chunks. This is sometimes referred to as the skirt, which usually has some unique considerations, especially when threading is involved. Each element in each 3 dimensional array is still responsible for a 1x1x1 volume, but additionally, each chunk is responsible for a larger defined volume as well.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter2/figure2.png&quot; alt=&quot;figure 2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
For very fine voxel resolutions, you’ll want to construct an octree. An octree is a recursive structure where 3D space is recursively subdivided into 8 regions. Any area that is one solid type of voxel does not need to be subdivided and is stored as one id. As you can see in the figure, for finer resolutions, there is a significant reduction in memory usage. The octree offers this reduction because volumetric data often has large, contiguous, homogenous areas. Now that our volumetric data is stored as a tree, we should access it similarly to doing a binary search. The figure below provides a visual explanation of why we can use the binary representation of the block’s coordinates to get its place in the tree. Reading from and writing to a file is still trivial- the octree must be saved recursively.
The octree has restrictions on it that allow it to function. The octree always has a ‘bottom’, where it will not divide area any further. Branches must know how far they are above this bottom- this will determine if they are accountable for a 2x2x2 volume, a 4x4x4 volume, an 8x8x8 volume, etc. Branches will always be accountable for cubic volume whose side lengths are a power of two above one. Solid areas that are not subdivided are stored as buds, which are the same but there can be 1x1x1 sized buds. (Other tree structures for storing different kinds of data will always be size 1x1x1).
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter2/figure3.png&quot; alt=&quot;figure 3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
In order to use an octree with an infinite world size, the last two methods can be combined- data is loaded and unloaded in portions with an octree representation. Instead of having an octree for each chunk, though, it’s faster to combine all of the octrees into one octree that expands as more data is loaded in. Without negative values, it’s easy to see how this would work. The tree representing some chunk is loaded, and then must be inserted into the world tree. First, the world tree must grow large enough to encapsulate the area inhabited by the chunk. Growing an octree is done by creating a new root node whose children consist of seven buds and the previous root node. The previous root node will be the lower left child, which ensures that the octree will expand up and to the right. The new root node will be twice as large in each dimension. Then, the tree must recursively divide the appropriate bud until there is a spot for the chunk to be placed. To divide a bud, the bud is replaced with a branch of the same size whose children are smaller buds. Only then can the chunk be placed in the world tree.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter2/figure4.png&quot; alt=&quot;figure 4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
To allow for negative values, a change must be made to the octree. When the tree expands, it has to expand in the negative direction as well as the positive direction. To accomplish this, the octree will alternate between making the old root node the new root node’s lower left child and making it the new root node’s upper right child. Geometrically speaking, the octree alternates between doubling forward and doubling backward. This is an extremely effective method for encapsulating all of space, but it makes finding locations in the tree more difficult. 
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter2/figure5.png&quot; alt=&quot;figure 5&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
A voxel’s location in the tree is no longer the same as its binary representation. Relying on the binary representation of the number to ‘wrap around’ would be unacceptable because it would cause discontinuities once the tree expands and begins taking the next most significant bit into consideration. The coordinates of each voxel must be transformed into ‘address space’ before their binary representations may be used to find its position in the tree. This transformation can be observed to be associative with addition (voxels have different addresses but consecutive addresses are still consecutive), which means to transform into address space is to add a certain offset to the coordinate and then take the binary representation. That offset should be 0 in address space, which logically I know has to be the repeating binary pattern 10101010.... Because the tree alternates between expanding positively and negatively, alternating between going down the left side of the tree and the right side will eventually end up at zero. I use a slight modification to this that ensures that chunk coordinates can be found by truncated division by the chunk size. 
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter2/figure6.png&quot; alt=&quot;figure 6&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
The tree can also be used to store hermitian data, but some small changes should be made. In addition to branches, for areas that contain changes, and buds, for uniform areas, There should also be features for areas that need to store a vertex and leaves for areas that need to store edges. As opposed to branches and buds, features and leaves are always size 1x1x1. The following diagram shows the inheritance tree or these structures.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter2/figure7.png&quot; alt=&quot;figure 7&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><summary type="html">Data storage is the second challenge to overcome. If the game has a reasonable, fixed size, and you can afford to store all data at once, you might as well just store it in a large 3D array. Geometrically, each element in the 3 dimensional array represents a 1x1x1 area. More often, though, you’ll either want the map size to be infinite or at least large enough that you can’t store all of that information at once. For that, you’ll need to break the map apart into reasonably sized pieces that can be read from and written to memory. There is often a bit of nuance with regards to threading and ensuring that you only attempt to generate mesh for a chunk when its neighbors are loaded too. There is always mesh data along the edge of each chunk that cannot be generated without data from other chunks. This is sometimes referred to as the skirt, which usually has some unique considerations, especially when threading is involved. Each element in each 3 dimensional array is still responsible for a 1x1x1 volume, but additionally, each chunk is responsible for a larger defined volume as well. For very fine voxel resolutions, you’ll want to construct an octree. An octree is a recursive structure where 3D space is recursively subdivided into 8 regions. Any area that is one solid type of voxel does not need to be subdivided and is stored as one id. As you can see in the figure, for finer resolutions, there is a significant reduction in memory usage. The octree offers this reduction because volumetric data often has large, contiguous, homogenous areas. Now that our volumetric data is stored as a tree, we should access it similarly to doing a binary search. The figure below provides a visual explanation of why we can use the binary representation of the block’s coordinates to get its place in the tree. Reading from and writing to a file is still trivial- the octree must be saved recursively. The octree has restrictions on it that allow it to function. The octree always has a ‘bottom’, where it will not divide area any further. Branches must know how far they are above this bottom- this will determine if they are accountable for a 2x2x2 volume, a 4x4x4 volume, an 8x8x8 volume, etc. Branches will always be accountable for cubic volume whose side lengths are a power of two above one. Solid areas that are not subdivided are stored as buds, which are the same but there can be 1x1x1 sized buds. (Other tree structures for storing different kinds of data will always be size 1x1x1). In order to use an octree with an infinite world size, the last two methods can be combined- data is loaded and unloaded in portions with an octree representation. Instead of having an octree for each chunk, though, it’s faster to combine all of the octrees into one octree that expands as more data is loaded in. Without negative values, it’s easy to see how this would work. The tree representing some chunk is loaded, and then must be inserted into the world tree. First, the world tree must grow large enough to encapsulate the area inhabited by the chunk. Growing an octree is done by creating a new root node whose children consist of seven buds and the previous root node. The previous root node will be the lower left child, which ensures that the octree will expand up and to the right. The new root node will be twice as large in each dimension. Then, the tree must recursively divide the appropriate bud until there is a spot for the chunk to be placed. To divide a bud, the bud is replaced with a branch of the same size whose children are smaller buds. Only then can the chunk be placed in the world tree. To allow for negative values, a change must be made to the octree. When the tree expands, it has to expand in the negative direction as well as the positive direction. To accomplish this, the octree will alternate between making the old root node the new root node’s lower left child and making it the new root node’s upper right child. Geometrically speaking, the octree alternates between doubling forward and doubling backward. This is an extremely effective method for encapsulating all of space, but it makes finding locations in the tree more difficult. A voxel’s location in the tree is no longer the same as its binary representation. Relying on the binary representation of the number to ‘wrap around’ would be unacceptable because it would cause discontinuities once the tree expands and begins taking the next most significant bit into consideration. The coordinates of each voxel must be transformed into ‘address space’ before their binary representations may be used to find its position in the tree. This transformation can be observed to be associative with addition (voxels have different addresses but consecutive addresses are still consecutive), which means to transform into address space is to add a certain offset to the coordinate and then take the binary representation. That offset should be 0 in address space, which logically I know has to be the repeating binary pattern 10101010.... Because the tree alternates between expanding positively and negatively, alternating between going down the left side of the tree and the right side will eventually end up at zero. I use a slight modification to this that ensures that chunk coordinates can be found by truncated division by the chunk size. The tree can also be used to store hermitian data, but some small changes should be made. In addition to branches, for areas that contain changes, and buds, for uniform areas, There should also be features for areas that need to store a vertex and leaves for areas that need to store edges. As opposed to branches and buds, features and leaves are always size 1x1x1. The following diagram shows the inheritance tree or these structures.</summary></entry><entry><title type="html">Voxel Continuity Algorithm</title><link href="http://localhost:4000/voxel/2018/08/13/voxel-continuity-algorithm.html" rel="alternate" type="text/html" title="Voxel Continuity Algorithm" /><published>2018-08-13T10:39:54-04:00</published><updated>2018-08-13T10:39:54-04:00</updated><id>http://localhost:4000/voxel/2018/08/13/voxel-continuity-algorithm</id><content type="html" xml:base="http://localhost:4000/voxel/2018/08/13/voxel-continuity-algorithm.html">&lt;p&gt;
Besides performance optimization, there are still things to do to enhance the voxel engine. One thing that voxel engines rarely do (though voxel farm does) is identify any structures that are not attached to the main structure and break them off into their own coordinate system so that they can obey a physics engine and fall. Having multiple coordinate systems is no problem at all- each coordinate system has a separate octree and a transform matrix. The real challenge is identifying disconnected volumes.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter4/figure1.png&quot; alt=&quot;figure 1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
The naive solution would be to attempt to pathfind from some point to each other solid voxel, which isn’t a viable solution because it would take forever.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter4/figure2.png&quot; alt=&quot;figure 2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
For the vast majority of cases, the octree structure can provide a crucial advantage. First, information about connectivity must be calculated and stored in a bitmask on each branch. This information would include whether the branch contains solid mass and whether that mass is contiguous to the mass of the branches neighboring it in each direction. The calculation is recursive, simple, and fast. 
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter4/figure3.png&quot; alt=&quot;figure 3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
Next, the octree is recursively checked for continuity with the following rules:
First, check all subtrees for continuity with the recursive step. After this, it can be assumed that all subtrees will be continuous, because if and when any children fail, a piece of the octree will break off into its own coordinate system, and its parent (this node) will be recalculated.
Next, see if the eight subtrees are continuous to each other, without considering any neighbors besides the eight. If they are, the test is passed. If they cannot be proven to be continuous or discontinuous without considering neighboring cells, the tree and its depth are added to a registry.
&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/vox/chapter4/figure4.png&quot; alt=&quot;figure 4&quot; /&gt;&lt;/p&gt;
&lt;p&gt;
Outside of the recursion, consider each tree in the registry, smallest depth first. Using a symmetric A* algorithm, the program attempts to pathfind through neighboring cells of the same depth to test continuity.
&lt;/p&gt;
&lt;ul&gt;
	&lt;li&gt;
	If a path is found, the tree is removed from the registry.
	&lt;img src=&quot;http://localhost:4000/assets/vox/chapter4/figure5.png&quot; /&gt;
	&lt;/li&gt;
	&lt;li&gt;
	If the A* algorithm runs out of open nodes, the side that ran out of open nodes must separate into a new coordinate system, and that tree’s parent node is added to the registry.
	&lt;img src=&quot;http://localhost:4000/assets/vox/chapter4/figure6.png&quot; /&gt;
	&lt;/li&gt;
	&lt;li&gt;
	If the A* algorithm attempts to add a cell that is in an unloaded chunk or in the registry to the open list, then the search is stopped and the node remains in the registry, for the program has not loaded enough data to determine continuity yet. The registry is revisited anytime a chunk loads in or when a chunk is checked for disconnected volumes.
	&lt;img src=&quot;http://localhost:4000/assets/vox/chapter4/figure7.png&quot; /&gt;
	&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
This approach is extremely efficient for a number of reasons. First, it naturally filters out the ‘easy cases’ before they even get to the registry. Easy cases are the ones where the subtrees are continuous without needing to consider neighboring cells. Almost all cases are easy cases, so it’s good that they can be handled with just a handful of bitwise operations. Second, path finding can be done at a higher level than on a block-per-block basis. This figure demonstrates what I mean and the difference this can make. Third, even when all else fails, symmetric A* is able to finish very fast for this use case.
&lt;p&gt;
&lt;/p&gt;
This algorithm also has very natural tie-ins for the rest of the game. Detecting when trees should stay in the registry until chunks load in is an enormous luxury, because it vastly reduces the number of paranoid recalculation that would have to be done if the program could not make this distinction. Also, when the symmetric A* runs out of open nodes and a floating island is identified, the closed list can be used as an exact itinerary for what parts of the octree must be replaced with air and moved into their own octree. The whole strategy is a great example of elegance in programming.
&lt;/p&gt;</content><author><name></name></author><summary type="html">Besides performance optimization, there are still things to do to enhance the voxel engine. One thing that voxel engines rarely do (though voxel farm does) is identify any structures that are not attached to the main structure and break them off into their own coordinate system so that they can obey a physics engine and fall. Having multiple coordinate systems is no problem at all- each coordinate system has a separate octree and a transform matrix. The real challenge is identifying disconnected volumes. The naive solution would be to attempt to pathfind from some point to each other solid voxel, which isn’t a viable solution because it would take forever. For the vast majority of cases, the octree structure can provide a crucial advantage. First, information about connectivity must be calculated and stored in a bitmask on each branch. This information would include whether the branch contains solid mass and whether that mass is contiguous to the mass of the branches neighboring it in each direction. The calculation is recursive, simple, and fast. Next, the octree is recursively checked for continuity with the following rules: First, check all subtrees for continuity with the recursive step. After this, it can be assumed that all subtrees will be continuous, because if and when any children fail, a piece of the octree will break off into its own coordinate system, and its parent (this node) will be recalculated. Next, see if the eight subtrees are continuous to each other, without considering any neighbors besides the eight. If they are, the test is passed. If they cannot be proven to be continuous or discontinuous without considering neighboring cells, the tree and its depth are added to a registry. Outside of the recursion, consider each tree in the registry, smallest depth first. Using a symmetric A* algorithm, the program attempts to pathfind through neighboring cells of the same depth to test continuity. If a path is found, the tree is removed from the registry. If the A* algorithm runs out of open nodes, the side that ran out of open nodes must separate into a new coordinate system, and that tree’s parent node is added to the registry. If the A* algorithm attempts to add a cell that is in an unloaded chunk or in the registry to the open list, then the search is stopped and the node remains in the registry, for the program has not loaded enough data to determine continuity yet. The registry is revisited anytime a chunk loads in or when a chunk is checked for disconnected volumes. This approach is extremely efficient for a number of reasons. First, it naturally filters out the ‘easy cases’ before they even get to the registry. Easy cases are the ones where the subtrees are continuous without needing to consider neighboring cells. Almost all cases are easy cases, so it’s good that they can be handled with just a handful of bitwise operations. Second, path finding can be done at a higher level than on a block-per-block basis. This figure demonstrates what I mean and the difference this can make. Third, even when all else fails, symmetric A* is able to finish very fast for this use case. This algorithm also has very natural tie-ins for the rest of the game. Detecting when trees should stay in the registry until chunks load in is an enormous luxury, because it vastly reduces the number of paranoid recalculation that would have to be done if the program could not make this distinction. Also, when the symmetric A* runs out of open nodes and a floating island is identified, the closed list can be used as an exact itinerary for what parts of the octree must be replaced with air and moved into their own octree. The whole strategy is a great example of elegance in programming.</summary></entry><entry><title type="html">Generating Interesting Isosurfaces</title><link href="http://localhost:4000/voxel/2018/08/13/generating-interesting-isosurfaces.html" rel="alternate" type="text/html" title="Generating Interesting Isosurfaces" /><published>2018-08-13T10:39:54-04:00</published><updated>2018-08-13T10:39:54-04:00</updated><id>http://localhost:4000/voxel/2018/08/13/generating-interesting-isosurfaces</id><content type="html" xml:base="http://localhost:4000/voxel/2018/08/13/generating-interesting-isosurfaces.html">&lt;p&gt;
- Now that we have a reliable way to sample and render isosurfaces, we need some interesting isosurfaces to render. Most good methods start with a base of some volumetric noise combined with the voxel’s vertical coordinate. I’m generating multiple different 3d samplers filled with random noise, and adding them together with different frequencies and amplitudes just like perlin noise for my volumetric noise function. I’m just doing linear interpolation, though, and its a fascinating thing because the interpolation method I’m using is clearly visible in the generated mesh. (See the attached example) the flatish parts that clearly change direction at each grid point is very distinctive of linear interpolation. In addition to subtracting the voxel’s vertical coordinate, I also subtract the voxel’s vertical coordinate truncate divided by 16 and then multiplied by 16 to give it those shelf-looking features. Because I’m not seeding the pseudorandom number generator, and I haven’t changed the generation algorithm much since ive started, ive become very familiar with the valley structure pictured.
&lt;/p&gt;</content><author><name></name></author><summary type="html">- Now that we have a reliable way to sample and render isosurfaces, we need some interesting isosurfaces to render. Most good methods start with a base of some volumetric noise combined with the voxel’s vertical coordinate. I’m generating multiple different 3d samplers filled with random noise, and adding them together with different frequencies and amplitudes just like perlin noise for my volumetric noise function. I’m just doing linear interpolation, though, and its a fascinating thing because the interpolation method I’m using is clearly visible in the generated mesh. (See the attached example) the flatish parts that clearly change direction at each grid point is very distinctive of linear interpolation. In addition to subtracting the voxel’s vertical coordinate, I also subtract the voxel’s vertical coordinate truncate divided by 16 and then multiplied by 16 to give it those shelf-looking features. Because I’m not seeding the pseudorandom number generator, and I haven’t changed the generation algorithm much since ive started, ive become very familiar with the valley structure pictured.</summary></entry></feed>
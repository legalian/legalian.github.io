<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Proof Engine structures | Parker Lawrence portfolio</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Proof Engine structures" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="TO DO: I&#39;m going to include visualizations from my gephi visualizer. The most basic building blocks in the proof deducer are statements. I define statements to be a kind of tree. Each node in the tree is a constant, some kind of operation, or a substitution variable. Note that statements are not necessarily numerical- they can have much more complex types than that (the type of a statement can also be represented as a statement). Examples include a-b, f(a,b,c), f(a+b-c,d,e). A node’s type, number of arguments, and the types of its arguments are determined by a signature, which I define. Like statements, signatures are also trees, but with key differences. When a node appears in a statement, it’s like a function call. Signatures are like function definitions. Functions may also be dependently typed. A signature’s type or the signatures of its arguments may be written in terms of substitution variables standing in for its parameters. In other words, dependently typed function have a type or arguments whose types depend on the function’s inputs. A powerful example of a dependently typed function is the reflexivity property, but to completely understand it, you’d either need some prior type theory knowledge or to read a few more chapters of this blog. Since signatures are recursive, parameters may also be functions. To pass a function to a function, function variables may be referenced within the argument that expects a function as a parameter. This is difficult to describe in words, so the figure below shows this in greater detail. In the following example, the ‘derivative at a point’ function’s signature is shown. It accepts two parameters- the function to differentiate, and the input to the derivative. From this, the second derivative of a function can be constructed. Each node may only reference signatures within its scope. When a statement is interpreted for any purpose, it is done so recursively, so that scope can be built on the way down. Scope takes the form of a staggered 2d array of signatures, so that each move down the tree adds another row to the scope. Nodes index into the scope with a pair of integers. The first row in the scope is always the complete set of type theory axioms that the proof deducer must build everything out of. Signatures are also interpreted with a scope. Because (in the case of dependently typed functions) each child signature or the type statement may reference any of the signature’s arguments as substitution variables, a signature adds its child signatures as a new row to the scope as it is interpreted. The proof deducer can be very difficult to debug. To sanitize inputs and ensure good output, statements must be type checked. Type checking involves using a signature to generate a statement’s type, and then compare the generated type with the expected type for that statement. The expected types of the node’s arguments are then generated and then the type checking is continued recursively. The proof deducer obsessively type checks all statements during development because it helps catch bugs. In type theory, two statements are judgmentally equal if and only if their structures are the same. Under this definition, 3+2 is judgmentally equivalent to 3+2, but not 2+3 or 5. When the program performs type checking for the purpose of sanitizing inputs or debugging, the expected type and the generated type are compared to see if they are judgmentally equal. If they are not, the program throws an exception. In other areas of the program, type checking is performed with different goals, such as setting the expected type equal to the generated type to solve for unknowns." />
<meta property="og:description" content="TO DO: I&#39;m going to include visualizations from my gephi visualizer. The most basic building blocks in the proof deducer are statements. I define statements to be a kind of tree. Each node in the tree is a constant, some kind of operation, or a substitution variable. Note that statements are not necessarily numerical- they can have much more complex types than that (the type of a statement can also be represented as a statement). Examples include a-b, f(a,b,c), f(a+b-c,d,e). A node’s type, number of arguments, and the types of its arguments are determined by a signature, which I define. Like statements, signatures are also trees, but with key differences. When a node appears in a statement, it’s like a function call. Signatures are like function definitions. Functions may also be dependently typed. A signature’s type or the signatures of its arguments may be written in terms of substitution variables standing in for its parameters. In other words, dependently typed function have a type or arguments whose types depend on the function’s inputs. A powerful example of a dependently typed function is the reflexivity property, but to completely understand it, you’d either need some prior type theory knowledge or to read a few more chapters of this blog. Since signatures are recursive, parameters may also be functions. To pass a function to a function, function variables may be referenced within the argument that expects a function as a parameter. This is difficult to describe in words, so the figure below shows this in greater detail. In the following example, the ‘derivative at a point’ function’s signature is shown. It accepts two parameters- the function to differentiate, and the input to the derivative. From this, the second derivative of a function can be constructed. Each node may only reference signatures within its scope. When a statement is interpreted for any purpose, it is done so recursively, so that scope can be built on the way down. Scope takes the form of a staggered 2d array of signatures, so that each move down the tree adds another row to the scope. Nodes index into the scope with a pair of integers. The first row in the scope is always the complete set of type theory axioms that the proof deducer must build everything out of. Signatures are also interpreted with a scope. Because (in the case of dependently typed functions) each child signature or the type statement may reference any of the signature’s arguments as substitution variables, a signature adds its child signatures as a new row to the scope as it is interpreted. The proof deducer can be very difficult to debug. To sanitize inputs and ensure good output, statements must be type checked. Type checking involves using a signature to generate a statement’s type, and then compare the generated type with the expected type for that statement. The expected types of the node’s arguments are then generated and then the type checking is continued recursively. The proof deducer obsessively type checks all statements during development because it helps catch bugs. In type theory, two statements are judgmentally equal if and only if their structures are the same. Under this definition, 3+2 is judgmentally equivalent to 3+2, but not 2+3 or 5. When the program performs type checking for the purpose of sanitizing inputs or debugging, the expected type and the generated type are compared to see if they are judgmentally equal. If they are not, the program throws an exception. In other areas of the program, type checking is performed with different goals, such as setting the expected type equal to the generated type to solve for unknowns." />
<link rel="canonical" href="http://localhost:4000/proof/2018/05/28/proof-engine-structures.html" />
<meta property="og:url" content="http://localhost:4000/proof/2018/05/28/proof-engine-structures.html" />
<meta property="og:site_name" content="Parker Lawrence portfolio" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-28T10:39:54-04:00" />
<script type="application/ld+json">
{"description":"TO DO: I&#39;m going to include visualizations from my gephi visualizer. The most basic building blocks in the proof deducer are statements. I define statements to be a kind of tree. Each node in the tree is a constant, some kind of operation, or a substitution variable. Note that statements are not necessarily numerical- they can have much more complex types than that (the type of a statement can also be represented as a statement). Examples include a-b, f(a,b,c), f(a+b-c,d,e). A node’s type, number of arguments, and the types of its arguments are determined by a signature, which I define. Like statements, signatures are also trees, but with key differences. When a node appears in a statement, it’s like a function call. Signatures are like function definitions. Functions may also be dependently typed. A signature’s type or the signatures of its arguments may be written in terms of substitution variables standing in for its parameters. In other words, dependently typed function have a type or arguments whose types depend on the function’s inputs. A powerful example of a dependently typed function is the reflexivity property, but to completely understand it, you’d either need some prior type theory knowledge or to read a few more chapters of this blog. Since signatures are recursive, parameters may also be functions. To pass a function to a function, function variables may be referenced within the argument that expects a function as a parameter. This is difficult to describe in words, so the figure below shows this in greater detail. In the following example, the ‘derivative at a point’ function’s signature is shown. It accepts two parameters- the function to differentiate, and the input to the derivative. From this, the second derivative of a function can be constructed. Each node may only reference signatures within its scope. When a statement is interpreted for any purpose, it is done so recursively, so that scope can be built on the way down. Scope takes the form of a staggered 2d array of signatures, so that each move down the tree adds another row to the scope. Nodes index into the scope with a pair of integers. The first row in the scope is always the complete set of type theory axioms that the proof deducer must build everything out of. Signatures are also interpreted with a scope. Because (in the case of dependently typed functions) each child signature or the type statement may reference any of the signature’s arguments as substitution variables, a signature adds its child signatures as a new row to the scope as it is interpreted. The proof deducer can be very difficult to debug. To sanitize inputs and ensure good output, statements must be type checked. Type checking involves using a signature to generate a statement’s type, and then compare the generated type with the expected type for that statement. The expected types of the node’s arguments are then generated and then the type checking is continued recursively. The proof deducer obsessively type checks all statements during development because it helps catch bugs. In type theory, two statements are judgmentally equal if and only if their structures are the same. Under this definition, 3+2 is judgmentally equivalent to 3+2, but not 2+3 or 5. When the program performs type checking for the purpose of sanitizing inputs or debugging, the expected type and the generated type are compared to see if they are judgmentally equal. If they are not, the program throws an exception. In other areas of the program, type checking is performed with different goals, such as setting the expected type equal to the generated type to solve for unknowns.","@type":"BlogPosting","url":"http://localhost:4000/proof/2018/05/28/proof-engine-structures.html","headline":"Proof Engine structures","dateModified":"2018-05-28T10:39:54-04:00","datePublished":"2018-05-28T10:39:54-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/proof/2018/05/28/proof-engine-structures.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Parker Lawrence portfolio" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Parker Lawrence portfolio</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/breadboardcomputer.html">Breadboard Computer</a><a class="page-link" href="/pokemonwebscraper.html">Pokemon Webscraper</a><a class="page-link" href="/puzzlegenerator.html">Puzzle Generator</a><a class="page-link" href="/tedtalk.html">TED Talk</a><a class="page-link" href="/voxelengine.html">Voxel Engine</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Proof Engine structures</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-05-28T10:39:54-04:00" itemprop="datePublished">May 28, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>
	TO DO: I'm going to include visualizations from my gephi visualizer.
The most basic building blocks in the proof deducer are statements. I define statements to be a kind of tree. Each node in the tree is a constant, some kind of operation, or a substitution variable. Note that statements are not necessarily numerical- they can have much more complex types than that (the type of a statement can also be represented as a statement). Examples include a-b, f(a,b,c), f(a+b-c,d,e).
</p>
<p><img src="http://localhost:4000/assets/proof/chapter1/figure1.png" alt="figure 1" /></p>
<p>
A node’s type, number of arguments, and the types of its arguments are determined by a signature, which I define. Like statements, signatures are also trees, but with key differences. When a node appears in a statement, it’s like a function call. Signatures are like function definitions.
</p>
<p><img src="http://localhost:4000/assets/proof/chapter1/figure2.png" alt="figure 2" /></p>
<p>
Functions may also be dependently typed. A signature’s type or the signatures of its arguments may be written in terms of substitution variables standing in for its parameters. In other words, dependently typed function have a type or arguments whose types depend on the function’s inputs. A powerful example of a dependently typed function is the reflexivity property, but to completely understand it, you’d either need some prior type theory knowledge or to read a few more chapters of this blog.
</p>
<p><img src="http://localhost:4000/assets/proof/chapter1/figure3.png" alt="figure 3" /></p>
<p>
Since signatures are recursive, parameters may also be functions. To pass a function to a function, function variables may be referenced within the argument that expects a function as a parameter. This is difficult to describe in words, so the figure below shows this in greater detail. In the following example, the ‘derivative at a point’ function’s signature is shown. It accepts two parameters- the function to differentiate, and the input to the derivative. From this, the second derivative of a function can be constructed.
</p>
<p><img src="http://localhost:4000/assets/proof/chapter1/figure4.png" alt="figure 4" /></p>
<p>
Each node may only reference signatures within its scope. When a statement is interpreted for any purpose, it is done so recursively, so that scope can be built on the way down. Scope takes the form of a staggered 2d array of signatures, so that each move down the tree adds another row to the scope. Nodes index into the scope with a pair of integers. The first row in the scope is always the complete set of type theory axioms that the proof deducer must build everything out of.
</p>
<p><img src="http://localhost:4000/assets/proof/chapter1/figure5.png" alt="figure 5" /></p>
<p>
Signatures are also interpreted with a scope. Because (in the case of dependently typed functions) each child signature or the type statement may reference any of the signature’s arguments as substitution variables, a signature adds its child signatures as a new row to the scope as it is interpreted.
</p>
<p><img src="http://localhost:4000/assets/proof/chapter1/figure6.png" alt="figure 6" /></p>
<p>
The proof deducer can be very difficult to debug. To sanitize inputs and ensure good output, statements must be type checked. Type checking involves using a signature to generate a statement’s type, and then compare the generated type with the expected type for that statement. The expected types of the node’s arguments are then generated and then the type checking is continued recursively. The proof deducer obsessively type checks all statements during development because it helps catch bugs.
</p>
<p><img src="http://localhost:4000/assets/proof/chapter1/figure7.png" alt="figure 7" /></p>
<p>
In type theory, two statements are judgmentally equal if and only if their structures are the same. Under this definition, 3+2 is judgmentally equivalent to 3+2, but not 2+3 or 5. When the program performs type checking for the purpose of sanitizing inputs or debugging, the expected type and the generated type are compared to see if they are judgmentally equal. If they are not, the program throws an exception. In other areas of the program, type checking is performed with different goals, such as setting the expected type equal to the generated type to solve for unknowns.
</p>
<p><img src="http://localhost:4000/assets/proof/chapter1/figure8.png" alt="figure 8" /></p>

<div>

<a href="/proof/2018/05/29/proof-engine-operations.html" style="float:right;">Proof engine operations &#8250;</a>


</div>

  </div><a class="u-url" href="/proof/2018/05/28/proof-engine-structures.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Parker Lawrence portfolio</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Parker Lawrence portfolio</li><li><a class="u-email" href="mailto:liverspleenkidney@gmail.com">liverspleenkidney@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/legalian"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">legalian</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Parker Lawrence&#39;s portfolio website and blog about interesting topics. If you&#39;re working on similar projects or you know Parker Lawrence, you may find this site interesting.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

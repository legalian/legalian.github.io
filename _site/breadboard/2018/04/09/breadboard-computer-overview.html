<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Breadboard computer overview | Parker Lawrence portfolio</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Breadboard computer overview" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="The computer is broken down into different modules that are connected to each other mostly via the bus. - My power supply is just a usb 5v power cable that I cut and soldered to breadboard wires. It works fine. - My clock is built using a 555 timer in astable mode. I swap out the capacitor to adjust the speed of the clock. For testing purposes, I usually keep the timer at 2Hz, because the slow timing makes it easy to see changes in LEDs that I use to test the machine. The clock outputs a square wave that signals to the machine to change states. Buffers are designed to store one binary word. This is how data is manipulated within the computer- binary operands are stored in buffers A and B so that the bus can be used to place the result of the operation in another location. The address buffer is the same- used for dereferencing pointers. The C buffer, on the other hand, is used for shuffling around data and debugging. Then, there’s the instruction buffer, used for storing the current instruction that is to be executed. The multiplexer is used to switch between accessing the portion of ram addressed by the instruction counter and accessing the portion of ram addressed by the address buffer. This is integral to the operation of the computer; sometimes it needs to access instructions and sometimes it needs to dereference pointers, but both operate on the same ram. The bus is an important concept for the computer. The bus is what allows the computer to arbitrarily move information between different buffers. In other parts of the computer, each wire has an input and one or more outputs. The bus, though, has many inputs and many outputs. At any one time, only one component is outputting to the bus and only one component is accepting input from the bus. The ram and c buffer can input to or output from the ram, but most components only listen to the bus. components can selectively output with tristate buffers- outputs can be high, low, or high impedance. Even though the computer is completely self-sufficient, I do have a raspberry PI connected to the bus for the purpose of testing and initialization. When the computer is started, I run a program on the raspberry PI to initialize the computer’s ram to a given set of instructions. To do this, the PI also has outputs that let it temporarily override the computer’s state and control its clock and instruction counter. Ram is set to input, multiplexer is set to listen to the instruction counter, and then the instruction counter counts while the PI sequentially reads the computer’s instructions onto the bus, populating the computer’s ram. Once that is finished, the instruction counter should be initialized to the location of the first instruction in memory. For my computer, that is always 0." />
<meta property="og:description" content="The computer is broken down into different modules that are connected to each other mostly via the bus. - My power supply is just a usb 5v power cable that I cut and soldered to breadboard wires. It works fine. - My clock is built using a 555 timer in astable mode. I swap out the capacitor to adjust the speed of the clock. For testing purposes, I usually keep the timer at 2Hz, because the slow timing makes it easy to see changes in LEDs that I use to test the machine. The clock outputs a square wave that signals to the machine to change states. Buffers are designed to store one binary word. This is how data is manipulated within the computer- binary operands are stored in buffers A and B so that the bus can be used to place the result of the operation in another location. The address buffer is the same- used for dereferencing pointers. The C buffer, on the other hand, is used for shuffling around data and debugging. Then, there’s the instruction buffer, used for storing the current instruction that is to be executed. The multiplexer is used to switch between accessing the portion of ram addressed by the instruction counter and accessing the portion of ram addressed by the address buffer. This is integral to the operation of the computer; sometimes it needs to access instructions and sometimes it needs to dereference pointers, but both operate on the same ram. The bus is an important concept for the computer. The bus is what allows the computer to arbitrarily move information between different buffers. In other parts of the computer, each wire has an input and one or more outputs. The bus, though, has many inputs and many outputs. At any one time, only one component is outputting to the bus and only one component is accepting input from the bus. The ram and c buffer can input to or output from the ram, but most components only listen to the bus. components can selectively output with tristate buffers- outputs can be high, low, or high impedance. Even though the computer is completely self-sufficient, I do have a raspberry PI connected to the bus for the purpose of testing and initialization. When the computer is started, I run a program on the raspberry PI to initialize the computer’s ram to a given set of instructions. To do this, the PI also has outputs that let it temporarily override the computer’s state and control its clock and instruction counter. Ram is set to input, multiplexer is set to listen to the instruction counter, and then the instruction counter counts while the PI sequentially reads the computer’s instructions onto the bus, populating the computer’s ram. Once that is finished, the instruction counter should be initialized to the location of the first instruction in memory. For my computer, that is always 0." />
<link rel="canonical" href="http://localhost:4000/breadboard/2018/04/09/breadboard-computer-overview.html" />
<meta property="og:url" content="http://localhost:4000/breadboard/2018/04/09/breadboard-computer-overview.html" />
<meta property="og:site_name" content="Parker Lawrence portfolio" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-04-09T10:39:54-04:00" />
<script type="application/ld+json">
{"description":"The computer is broken down into different modules that are connected to each other mostly via the bus. - My power supply is just a usb 5v power cable that I cut and soldered to breadboard wires. It works fine. - My clock is built using a 555 timer in astable mode. I swap out the capacitor to adjust the speed of the clock. For testing purposes, I usually keep the timer at 2Hz, because the slow timing makes it easy to see changes in LEDs that I use to test the machine. The clock outputs a square wave that signals to the machine to change states. Buffers are designed to store one binary word. This is how data is manipulated within the computer- binary operands are stored in buffers A and B so that the bus can be used to place the result of the operation in another location. The address buffer is the same- used for dereferencing pointers. The C buffer, on the other hand, is used for shuffling around data and debugging. Then, there’s the instruction buffer, used for storing the current instruction that is to be executed. The multiplexer is used to switch between accessing the portion of ram addressed by the instruction counter and accessing the portion of ram addressed by the address buffer. This is integral to the operation of the computer; sometimes it needs to access instructions and sometimes it needs to dereference pointers, but both operate on the same ram. The bus is an important concept for the computer. The bus is what allows the computer to arbitrarily move information between different buffers. In other parts of the computer, each wire has an input and one or more outputs. The bus, though, has many inputs and many outputs. At any one time, only one component is outputting to the bus and only one component is accepting input from the bus. The ram and c buffer can input to or output from the ram, but most components only listen to the bus. components can selectively output with tristate buffers- outputs can be high, low, or high impedance. Even though the computer is completely self-sufficient, I do have a raspberry PI connected to the bus for the purpose of testing and initialization. When the computer is started, I run a program on the raspberry PI to initialize the computer’s ram to a given set of instructions. To do this, the PI also has outputs that let it temporarily override the computer’s state and control its clock and instruction counter. Ram is set to input, multiplexer is set to listen to the instruction counter, and then the instruction counter counts while the PI sequentially reads the computer’s instructions onto the bus, populating the computer’s ram. Once that is finished, the instruction counter should be initialized to the location of the first instruction in memory. For my computer, that is always 0.","@type":"BlogPosting","url":"http://localhost:4000/breadboard/2018/04/09/breadboard-computer-overview.html","headline":"Breadboard computer overview","dateModified":"2018-04-09T10:39:54-04:00","datePublished":"2018-04-09T10:39:54-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/breadboard/2018/04/09/breadboard-computer-overview.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Parker Lawrence portfolio" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Parker Lawrence portfolio</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/breadboardcomputer.html">Breadboard Computer</a><a class="page-link" href="/pokemonwebscraper.html">Pokemon Webscraper</a><a class="page-link" href="/puzzlegenerator.html">Puzzle Generator</a><a class="page-link" href="/tedtalk.html">TED Talk</a><a class="page-link" href="/voxelengine.html">Voxel Engine</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Breadboard computer overview</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-04-09T10:39:54-04:00" itemprop="datePublished">Apr 9, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>
The computer is broken down into different modules that are connected to each other mostly via the bus.
</p>
<p><img src="http://localhost:4000/assets/breadboard/chapter1/figure1.png" alt="figure 1" /></p>
<p>
- My power supply is just a usb 5v power cable that I cut and soldered to breadboard wires. It works fine.
- My clock is built using a 555 timer in astable mode. I swap out the capacitor to adjust the speed of the clock. For testing purposes, I usually keep the timer at 2Hz, because the slow timing makes it easy to see changes in LEDs that I use to test the machine. The clock outputs a square wave that signals to the machine to change states.
Buffers are designed to store one binary word. This is how data is manipulated within the computer- binary operands are stored in buffers A and B so that the bus can be used to place the result of the operation in another location. The address buffer is the same- used for dereferencing pointers. The C buffer, on the other hand, is used for shuffling around data and debugging. Then, there’s the instruction buffer, used for storing the current instruction that is to be executed. 
</p>
<p><img src="http://localhost:4000/assets/breadboard/chapter1/figure2.png" alt="figure 2" /></p>
<p>
The multiplexer is used to switch between accessing the portion of ram addressed by the instruction counter and accessing the portion of ram addressed by the address buffer. This is integral to the operation of the computer; sometimes it needs to access instructions and sometimes it needs to dereference pointers, but both operate on the same ram. 
</p>
<p><img src="http://localhost:4000/assets/breadboard/chapter1/figure3.png" alt="figure 3" /></p>
<p>
The bus is an important concept for the computer. The bus is what allows the computer to arbitrarily move information between different buffers. In other parts of the computer, each wire has an input and one or more outputs. The bus, though, has many inputs and many outputs. At any one time, only one component is outputting to the bus and only one component is accepting input from the bus. The ram and c buffer can input to or output from the ram, but most components only listen to the bus. components can selectively output with tristate buffers- outputs can be high, low, or high impedance.
</p>
<p><img src="http://localhost:4000/assets/breadboard/chapter1/figure4.png" alt="figure 4" /></p>
<p>
Even though the computer is completely self-sufficient, I do have a raspberry PI connected to the bus for the purpose of testing and initialization. When the computer is started, I run a program on the raspberry PI to initialize the computer’s ram to a given set of instructions. To do this, the PI also has outputs that let it temporarily override the computer’s state and control its clock and instruction counter. Ram is set to input, multiplexer is set to listen to the instruction counter, and then the instruction counter counts while the PI sequentially reads the computer’s instructions onto the bus, populating the computer’s ram. Once that is finished, the instruction counter should be initialized to the location of the first instruction in memory. For my computer, that is always 0. 
</p>
<p><img src="http://localhost:4000/assets/breadboard/chapter1/figure5.png" alt="figure 5" /></p>

<div>

<a href="/breadboard/2018/04/16/breadboard-computer-operations.html" style="float:right;">Breadboard computer operations &#8250;</a>


</div>


  </div><a class="u-url" href="/breadboard/2018/04/09/breadboard-computer-overview.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Parker Lawrence portfolio</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Parker Lawrence portfolio</li><li><a class="u-email" href="mailto:liverspleenkidney@gmail.com">liverspleenkidney@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/legalian"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">legalian</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Parker Lawrence&#39;s portfolio website and blog about interesting topics. If you&#39;re working on similar projects or you know Parker Lawrence, you may find this site interesting.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>

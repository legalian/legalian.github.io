<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.5.0 -->
<title>Custom Language Compiler | Parker Lawrence portfolio</title>
<meta name="generator" content="Jekyll v3.8.3" />
<meta property="og:title" content="Custom Language Compiler" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="This computer cannot accept normal instructions, which means I had to write a compiler that can produce the special kind of assembly language that the computer can execute. Rather than compile an existing language, I made a very barebones language that I named K. The language is first tokenized, and then interpreted into an intermediate structure which can be very quickly turned into my assembly. For more about parsing, see the proof software project. The intermediate structure representation of the program is a tree. For this simplified language, there are expression nodes and structure nodes. The root node of the program is a structure node. Structure nodes are for blocks of code such as loops, conditionals, variable declarations, assignments, and functions. Expression nodes are for connectives within an expression such as addition, subtraction, variable reference, and the like. Variable declarations are the simplest structure node. They are made to chain together and do not become assembly language, only influence the stack, which changes the way later structures are parsed. Assignments are the next structure node. I make assignment a structure rather than an expression to simplify the language. They translate very simply- they just evaluate the expressions they contain into the variable. Conditionals are simple, too. First, they evaluate their expression into the C buffer. Then, they generate an SKP instruction for the C buffer followed by a SET instruction to the instruction counter (essentially a JMP). Then, the conditional’s body is evaluated. Now that the number of instructions that the body evaluates to is known, the JMP instruction is revisited to set its destination. Loops are similar to conditionals. They have another JMP instruction added after the body instructions that sends the counter back to just before the expression is evaluated. Function declarations turn into a JMP instruction to ensure that the function doesn’t run when it is declared, and then each parameter turns into a variable declaration on the stack. When the function is called, any arguments will be evaluated into the first words onto the stack. As opposed to structure nodes, expression nodes are given locations to leave the expression result, be it a buffer or a location in RAM. This is how assignments work; all they do is pass the variable’s location along to their expressions. When the location is in RAM, the program assumes that the address buffer will be left at that location after the expression finishes. Constants are the simplest expression nodes. They turn into SET instructions. Variables are much more complicated. Each time the program wants to access a variable on the stack, it must add the stack offset to the variable’s position relative to it, and set the address buffer to the result. When looking at the instructions generated by my compiler, most of the computer’s work happens to be shuffling buffers for this purpose. If I were building the computer over again, I’d change the address buffer to be two buffers connected by a full adder. That way, one buffer could contain the stack offset, cutting out ~70% of each program’s instructions. Allowing one of those buffers to be read from would improve it even more, providing a more elegant way to increase or decrease the stack offset. While parsing binary expressions, an additional offset on top of the stack offset is incremented to allow words to be temporarily stored in memory, if they need to be. The following flowchart describes the optimizations done to a binary expression (if possible) The program also introduces two operators for clamping values from 16 bit integer range to a 1 or 0. Essentially, a ‘truthiness’ test, and an inverse truthiness test. The program also supports reference and dereference operators. Pointers are the same data type as any other word, and there are no protections to ensure that the machine doesn’t change memory in use by the OS. Reference operators are are turned into constants. Function calls must add onto the stack offset, leave the current position in instructions in ram, and then evaluate each of its parameter expressions into the stack variables they correspond to inside the function’s scope. After that, the function jumps to the function’s position in the instructions. Once the function reaches its return statement, it subtracts from the stack and leaves the function’s return value in the C buffer. I was originally going to implement a heap with memory allocation and reallocation operators, but I realized that each one would turn into a lot of instructions and ram usage. The computer’s ALU occasionally mishandles operations, so small programs will execute fine, but any program over 80 operations isn’t worth trying. I spent a long time trying to fix that problem, because it would allow me to create a whole OS for the system, but the project got pushed to the wayside when summer ended." />
<meta property="og:description" content="This computer cannot accept normal instructions, which means I had to write a compiler that can produce the special kind of assembly language that the computer can execute. Rather than compile an existing language, I made a very barebones language that I named K. The language is first tokenized, and then interpreted into an intermediate structure which can be very quickly turned into my assembly. For more about parsing, see the proof software project. The intermediate structure representation of the program is a tree. For this simplified language, there are expression nodes and structure nodes. The root node of the program is a structure node. Structure nodes are for blocks of code such as loops, conditionals, variable declarations, assignments, and functions. Expression nodes are for connectives within an expression such as addition, subtraction, variable reference, and the like. Variable declarations are the simplest structure node. They are made to chain together and do not become assembly language, only influence the stack, which changes the way later structures are parsed. Assignments are the next structure node. I make assignment a structure rather than an expression to simplify the language. They translate very simply- they just evaluate the expressions they contain into the variable. Conditionals are simple, too. First, they evaluate their expression into the C buffer. Then, they generate an SKP instruction for the C buffer followed by a SET instruction to the instruction counter (essentially a JMP). Then, the conditional’s body is evaluated. Now that the number of instructions that the body evaluates to is known, the JMP instruction is revisited to set its destination. Loops are similar to conditionals. They have another JMP instruction added after the body instructions that sends the counter back to just before the expression is evaluated. Function declarations turn into a JMP instruction to ensure that the function doesn’t run when it is declared, and then each parameter turns into a variable declaration on the stack. When the function is called, any arguments will be evaluated into the first words onto the stack. As opposed to structure nodes, expression nodes are given locations to leave the expression result, be it a buffer or a location in RAM. This is how assignments work; all they do is pass the variable’s location along to their expressions. When the location is in RAM, the program assumes that the address buffer will be left at that location after the expression finishes. Constants are the simplest expression nodes. They turn into SET instructions. Variables are much more complicated. Each time the program wants to access a variable on the stack, it must add the stack offset to the variable’s position relative to it, and set the address buffer to the result. When looking at the instructions generated by my compiler, most of the computer’s work happens to be shuffling buffers for this purpose. If I were building the computer over again, I’d change the address buffer to be two buffers connected by a full adder. That way, one buffer could contain the stack offset, cutting out ~70% of each program’s instructions. Allowing one of those buffers to be read from would improve it even more, providing a more elegant way to increase or decrease the stack offset. While parsing binary expressions, an additional offset on top of the stack offset is incremented to allow words to be temporarily stored in memory, if they need to be. The following flowchart describes the optimizations done to a binary expression (if possible) The program also introduces two operators for clamping values from 16 bit integer range to a 1 or 0. Essentially, a ‘truthiness’ test, and an inverse truthiness test. The program also supports reference and dereference operators. Pointers are the same data type as any other word, and there are no protections to ensure that the machine doesn’t change memory in use by the OS. Reference operators are are turned into constants. Function calls must add onto the stack offset, leave the current position in instructions in ram, and then evaluate each of its parameter expressions into the stack variables they correspond to inside the function’s scope. After that, the function jumps to the function’s position in the instructions. Once the function reaches its return statement, it subtracts from the stack and leaves the function’s return value in the C buffer. I was originally going to implement a heap with memory allocation and reallocation operators, but I realized that each one would turn into a lot of instructions and ram usage. The computer’s ALU occasionally mishandles operations, so small programs will execute fine, but any program over 80 operations isn’t worth trying. I spent a long time trying to fix that problem, because it would allow me to create a whole OS for the system, but the project got pushed to the wayside when summer ended." />
<link rel="canonical" href="http://localhost:4000/breadboard/2018/05/07/custom-language-compiler.html" />
<meta property="og:url" content="http://localhost:4000/breadboard/2018/05/07/custom-language-compiler.html" />
<meta property="og:site_name" content="Parker Lawrence portfolio" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2018-05-07T10:39:54-04:00" />
<script type="application/ld+json">
{"description":"This computer cannot accept normal instructions, which means I had to write a compiler that can produce the special kind of assembly language that the computer can execute. Rather than compile an existing language, I made a very barebones language that I named K. The language is first tokenized, and then interpreted into an intermediate structure which can be very quickly turned into my assembly. For more about parsing, see the proof software project. The intermediate structure representation of the program is a tree. For this simplified language, there are expression nodes and structure nodes. The root node of the program is a structure node. Structure nodes are for blocks of code such as loops, conditionals, variable declarations, assignments, and functions. Expression nodes are for connectives within an expression such as addition, subtraction, variable reference, and the like. Variable declarations are the simplest structure node. They are made to chain together and do not become assembly language, only influence the stack, which changes the way later structures are parsed. Assignments are the next structure node. I make assignment a structure rather than an expression to simplify the language. They translate very simply- they just evaluate the expressions they contain into the variable. Conditionals are simple, too. First, they evaluate their expression into the C buffer. Then, they generate an SKP instruction for the C buffer followed by a SET instruction to the instruction counter (essentially a JMP). Then, the conditional’s body is evaluated. Now that the number of instructions that the body evaluates to is known, the JMP instruction is revisited to set its destination. Loops are similar to conditionals. They have another JMP instruction added after the body instructions that sends the counter back to just before the expression is evaluated. Function declarations turn into a JMP instruction to ensure that the function doesn’t run when it is declared, and then each parameter turns into a variable declaration on the stack. When the function is called, any arguments will be evaluated into the first words onto the stack. As opposed to structure nodes, expression nodes are given locations to leave the expression result, be it a buffer or a location in RAM. This is how assignments work; all they do is pass the variable’s location along to their expressions. When the location is in RAM, the program assumes that the address buffer will be left at that location after the expression finishes. Constants are the simplest expression nodes. They turn into SET instructions. Variables are much more complicated. Each time the program wants to access a variable on the stack, it must add the stack offset to the variable’s position relative to it, and set the address buffer to the result. When looking at the instructions generated by my compiler, most of the computer’s work happens to be shuffling buffers for this purpose. If I were building the computer over again, I’d change the address buffer to be two buffers connected by a full adder. That way, one buffer could contain the stack offset, cutting out ~70% of each program’s instructions. Allowing one of those buffers to be read from would improve it even more, providing a more elegant way to increase or decrease the stack offset. While parsing binary expressions, an additional offset on top of the stack offset is incremented to allow words to be temporarily stored in memory, if they need to be. The following flowchart describes the optimizations done to a binary expression (if possible) The program also introduces two operators for clamping values from 16 bit integer range to a 1 or 0. Essentially, a ‘truthiness’ test, and an inverse truthiness test. The program also supports reference and dereference operators. Pointers are the same data type as any other word, and there are no protections to ensure that the machine doesn’t change memory in use by the OS. Reference operators are are turned into constants. Function calls must add onto the stack offset, leave the current position in instructions in ram, and then evaluate each of its parameter expressions into the stack variables they correspond to inside the function’s scope. After that, the function jumps to the function’s position in the instructions. Once the function reaches its return statement, it subtracts from the stack and leaves the function’s return value in the C buffer. I was originally going to implement a heap with memory allocation and reallocation operators, but I realized that each one would turn into a lot of instructions and ram usage. The computer’s ALU occasionally mishandles operations, so small programs will execute fine, but any program over 80 operations isn’t worth trying. I spent a long time trying to fix that problem, because it would allow me to create a whole OS for the system, but the project got pushed to the wayside when summer ended.","@type":"BlogPosting","url":"http://localhost:4000/breadboard/2018/05/07/custom-language-compiler.html","headline":"Custom Language Compiler","dateModified":"2018-05-07T10:39:54-04:00","datePublished":"2018-05-07T10:39:54-04:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/breadboard/2018/05/07/custom-language-compiler.html"},"@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Parker Lawrence portfolio" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Parker Lawrence portfolio</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a><a class="page-link" href="/breadboardcomputer.html">Breadboard Computer</a><a class="page-link" href="/pokemonwebscraper.html">Pokemon Webscraper</a><a class="page-link" href="/puzzlegenerator.html">Puzzle Generator</a><a class="page-link" href="/tedtalk.html">TED Talk</a><a class="page-link" href="/voxelengine.html">Voxel Engine</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Custom Language Compiler</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2018-05-07T10:39:54-04:00" itemprop="datePublished">May 7, 2018
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>
This computer cannot accept normal instructions, which means I had to write a compiler that can produce the special kind of assembly language that the computer can execute. Rather than compile an existing language, I made a very barebones language that I named K. The language is first tokenized, and then interpreted into an intermediate structure which can be very quickly turned into my assembly. For more about parsing, see the proof software project. 
</p>
<p><img src="http://localhost:4000/assets/breadboard/chapter4/figure1.png" alt="figure 1" /></p>
<p>
The intermediate structure representation of the program is a tree. For this simplified language, there are expression nodes and structure nodes. The root node of the program is a structure node. Structure nodes are for blocks of code such as loops, conditionals, variable declarations, assignments, and functions. Expression nodes are for connectives within an expression such as addition, subtraction, variable reference, and the like.
</p>
<ul>
	<li>
	Variable declarations are the simplest structure node. They are made to chain together and do not become assembly language, only influence the stack, which changes the way later structures are parsed. 
	<img src="http://localhost:4000/assets/breadboard/chapter4/figure2.png" />
	</li>
	<li>
	Assignments are the next structure node. I make assignment a structure rather than an expression to simplify the language. They translate very simply- they just evaluate the expressions they contain into the variable. 
	<img src="http://localhost:4000/assets/breadboard/chapter4/figure3.png" />
	</li>
	<li>
	Conditionals are simple, too. First, they evaluate their expression into the C buffer. Then, they generate an SKP instruction for the C buffer followed by a SET instruction to the instruction counter (essentially a JMP). Then, the conditional’s body is evaluated. Now that the number of instructions that the body evaluates to is known, the JMP instruction is revisited to set its destination. 
	<img src="http://localhost:4000/assets/breadboard/chapter4/figure4.png" />
	</li>
	<li>
	Loops are similar to conditionals. They have another JMP instruction added after the body instructions that sends the counter back to just before the expression is evaluated. 
	<img src="http://localhost:4000/assets/breadboard/chapter4/figure5.png" />
	</li>
	<li>
	Function declarations turn into a JMP instruction to ensure that the function doesn’t run when it is declared, and then each parameter turns into a variable declaration on the stack. When the function is called, any arguments will be evaluated into the first words onto the stack. 
	<img src="http://localhost:4000/assets/breadboard/chapter4/figure6.png" />
	</li>
</ul>
<p>
As opposed to structure nodes, expression nodes are given locations to leave the expression result, be it a buffer or a location in RAM. This is how assignments work; all they do is pass the variable’s location along to their expressions. When the location is in RAM, the program assumes that the address buffer will be left at that location after the expression finishes.
</p>
<ul>
	<li>
	Constants are the simplest expression nodes. They turn into SET instructions. 
	<img src="http://localhost:4000/assets/breadboard/chapter4/figure7.png" />
	</li>
	<li>
	Variables are much more complicated. Each time the program wants to access a variable on the stack, it must add the stack offset to the variable’s position relative to it, and set the address buffer to the result. When looking at the instructions generated by my compiler, most of the computer’s work happens to be shuffling buffers for this purpose. If I were building the computer over again, I’d change the address buffer to be two buffers connected by a full adder. That way, one buffer could contain the stack offset, cutting out ~70% of each program’s instructions. Allowing one of those buffers to be read from would improve it even more, providing a more elegant way to increase or decrease the stack offset. 
	<img src="http://localhost:4000/assets/breadboard/chapter4/figure8.png" />
	</li>
	<li>
	While parsing binary expressions, an additional offset on top of the stack offset is incremented to allow words to be temporarily stored in memory, if they need to be. The following flowchart describes the optimizations done to a binary expression (if possible) 
	<img src="http://localhost:4000/assets/breadboard/chapter4/figure9.png" />
	</li>
	<li>
	The program also introduces two operators for clamping values from 16 bit integer range to a 1 or 0. Essentially, a ‘truthiness’ test, and an inverse truthiness test.
	<img src="http://localhost:4000/assets/breadboard/chapter4/figure10.png" />
	</li>
	<li>
	The program also supports reference and dereference operators. Pointers are the same data type as any other word, and there are no protections to ensure that the machine doesn’t change memory in use by the OS. Reference operators are are turned into constants. 
	<img src="http://localhost:4000/assets/breadboard/chapter4/figure11.png" />
	</li>
	<li>
	Function calls must add onto the stack offset, leave the current position in instructions in ram, and then evaluate each of its parameter expressions into the stack variables they correspond to inside the function’s scope. After that, the function jumps to the function’s position in the instructions. Once the function reaches its return statement, it subtracts from the stack and leaves the function’s return value in the C buffer. 
	<img src="http://localhost:4000/assets/breadboard/chapter4/figure12.png" />
	</li>
	<li>
	I was originally going to implement a heap with memory allocation and reallocation operators, but I realized that each one would turn into a lot of instructions and ram usage. The computer’s ALU occasionally mishandles operations, so small programs will execute fine, but any program over 80 operations isn’t worth trying. I spent a long time trying to fix that problem, because it would allow me to create a whole OS for the system, but the project got pushed to the wayside when summer ended. 
	</li>
</ul>

<div>

<a href="/breadboard/2018/05/14/breadboard-computer-pictures.html" style="float:right;">Breadboard computer pictures &#8250;</a>


<a href="/breadboard/2018/04/30/breadboard-computer-alu.html" class="float:left;">&#8249; Breadboard computer ALU</a>

</div>

  </div><a class="u-url" href="/breadboard/2018/05/07/custom-language-compiler.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Parker Lawrence portfolio</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Parker Lawrence portfolio</li><li><a class="u-email" href="mailto:liverspleenkidney@gmail.com">liverspleenkidney@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/legalian"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">legalian</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>Parker Lawrence&#39;s portfolio website and blog about interesting topics. If you&#39;re working on similar projects or you know Parker Lawrence, you may find this site interesting.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
